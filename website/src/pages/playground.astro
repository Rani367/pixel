---
import BaseLayout from '../layouts/BaseLayout.astro';

const examples = [
  {
    name: 'Bouncing Ball',
    code: `// A ball that bounces around the screen
// Changes color each time it hits a wall

x = 400
y = 300
speed_x = 200
speed_y = 150
color = CYAN

function on_start() {
    create_window(800, 600, "Bouncing Ball")
}

function on_update(dt) {
    // Move the ball
    x = x + speed_x * dt
    y = y + speed_y * dt

    // Bounce off walls and pick a new color
    if x < 20 or x > 780 {
        speed_x = -speed_x
        color = rgb(random_range(50, 255), random_range(50, 255), random_range(50, 255))
    }
    if y < 20 or y > 580 {
        speed_y = -speed_y
        color = rgb(random_range(50, 255), random_range(50, 255), random_range(50, 255))
    }
}

function on_draw() {
    clear(rgb(20, 20, 40))
    draw_circle(x, y, 20, color)
}`
  },
  {
    name: 'Keyboard Movement',
    code: `// Move a square with the arrow keys

x = 400
y = 300
speed = 200

function on_start() {
    create_window(800, 600, "Arrow Keys to Move")
}

function on_update(dt) {
    // Move in the direction of pressed keys
    if key_down(KEY_LEFT)  { x = x - speed * dt }
    if key_down(KEY_RIGHT) { x = x + speed * dt }
    if key_down(KEY_UP)    { y = y - speed * dt }
    if key_down(KEY_DOWN)  { y = y + speed * dt }
}

function on_draw() {
    clear(rgb(20, 20, 40))
    draw_rect(x - 25, y - 25, 50, 50, YELLOW)
}`
  },
  {
    name: 'Particles',
    code: `// Click anywhere to create particles that fall with gravity

particles = []

function on_start() {
    create_window(800, 600, "Click to Spawn Particles")
}

function on_update(dt) {
    // Create particles when mouse is pressed
    if mouse_down(MOUSE_LEFT) {
        i = 0
        while i < 5 {
            p = {}
            p.x = mouse_x()
            p.y = mouse_y()
            p.vx = random_range(-100, 100)
            p.vy = random_range(-200, -50)
            p.life = 1.0
            push(particles, p)
            i = i + 1
        }
    }

    // Update each particle
    i = 0
    while i < len(particles) {
        p = particles[i]
        p.x = p.x + p.vx * dt
        p.y = p.y + p.vy * dt
        p.vy = p.vy + 400 * dt  // gravity
        p.life = p.life - dt

        if p.life <= 0 {
            remove(particles, i)
        } else {
            i = i + 1
        }
    }
}

function on_draw() {
    clear(rgb(20, 20, 40))

    i = 0
    while i < len(particles) {
        p = particles[i]
        alpha = floor(p.life * 255)
        draw_circle(p.x, p.y, 5, rgba(255, 100, 50, alpha))
        i = i + 1
    }
}`
  }
];
---

<BaseLayout title="Pixel Playground" description="Try Pixel programming language in your browser. Write and run 2D game code instantly with our interactive online playground." keywords={["Pixel playground", "online code editor", "try Pixel", "game programming sandbox", "browser game development"]}>
  <div class="h-[calc(100vh-4rem)] flex flex-col">
    <!-- Toolbar -->
    <div class="border-b border-zinc-200 dark:border-zinc-800 px-3 sm:px-4 py-2 sm:py-3 flex items-center justify-between bg-zinc-50 dark:bg-zinc-900 gap-2">
      <div class="flex items-center gap-2 sm:gap-4 min-w-0">
        <label class="text-xs sm:text-sm font-medium flex items-center gap-1 sm:gap-2 min-w-0">
          <span class="hidden sm:inline">Example:</span>
          <select id="example-select" class="px-2 sm:px-3 py-1 sm:py-1.5 bg-white dark:bg-zinc-800 border border-zinc-300 dark:border-zinc-700 rounded-lg text-xs sm:text-sm min-w-0">
            {examples.map((ex, i) => (
              <option value={i}>{ex.name}</option>
            ))}
          </select>
        </label>
        <span id="status-badge" class="hidden px-2 py-1 text-xs font-medium rounded bg-cyan-500/20 text-cyan-400">
          Running
        </span>
      </div>
      <div class="flex items-center gap-2 shrink-0">
        <!-- Loading indicator -->
        <span id="loading-indicator" class="flex items-center gap-2 text-xs sm:text-sm text-zinc-500">
          <svg class="w-4 h-4 animate-spin" fill="none" viewBox="0 0 24 24">
            <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
            <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
          </svg>
          <span class="hidden sm:inline">Loading runtime...</span>
        </span>
        <button
          id="run-btn"
          class="hidden px-3 sm:px-4 py-1.5 sm:py-2 bg-cyan-400 text-zinc-900 font-medium rounded-lg hover:bg-cyan-500 transition-colors flex items-center gap-1 sm:gap-2 text-sm"
          disabled
        >
          <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24">
            <path d="M8 5v14l11-7z"/>
          </svg>
          Run
        </button>
        <button
          id="stop-btn"
          class="hidden px-3 sm:px-4 py-1.5 sm:py-2 bg-red-500 text-white font-medium rounded-lg hover:bg-red-600 transition-colors flex items-center gap-1 sm:gap-2 text-sm"
        >
          <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24">
            <rect x="6" y="6" width="12" height="12"/>
          </svg>
          Stop
        </button>
      </div>
    </div>

    <!-- Main Content -->
    <div class="flex-1 flex flex-col md:flex-row min-h-0">
      <!-- Editor Panel -->
      <div class="h-1/2 md:h-auto md:w-1/2 border-b md:border-b-0 md:border-r border-zinc-200 dark:border-zinc-800 flex flex-col min-h-0">
        <div class="px-3 sm:px-4 py-2 text-xs font-medium text-zinc-500 dark:text-zinc-400 bg-zinc-100 dark:bg-zinc-900 border-b border-zinc-200 dark:border-zinc-800 flex items-center justify-between shrink-0">
          <span>game.pixel</span>
          <span class="text-zinc-400 dark:text-zinc-600 text-[10px] hidden sm:inline">Ctrl+Enter to run</span>
        </div>
        <div id="editor" class="flex-1 overflow-auto scrollbar-hide min-h-0"></div>
      </div>

      <!-- Output Panel -->
      <div class="h-1/2 md:h-auto md:w-1/2 flex flex-col min-h-0">
        <div class="px-3 sm:px-4 py-2 text-xs font-medium text-zinc-500 dark:text-zinc-400 bg-zinc-100 dark:bg-zinc-900 border-b border-zinc-200 dark:border-zinc-800 shrink-0">
          Output
        </div>
        <div id="canvas-container" class="flex-1 bg-zinc-100 dark:bg-zinc-900 flex items-center justify-center overflow-hidden p-2 sm:p-4 min-h-0">
          <canvas id="canvas" width="800" height="600" tabindex="0" class="max-w-full max-h-full bg-zinc-200 dark:bg-zinc-950 border-2 border-zinc-400 dark:border-zinc-600 rounded focus:outline-none focus:ring-2 focus:ring-cyan-400"></canvas>
        </div>
        <div class="h-24 md:h-48 border-t border-zinc-200 dark:border-zinc-800 bg-zinc-100 dark:bg-zinc-950 flex flex-col shrink-0">
          <div class="px-3 sm:px-4 py-2 text-xs font-medium text-zinc-500 border-b border-zinc-200 dark:border-zinc-800 flex items-center justify-between shrink-0">
            <span>Console</span>
            <button id="clear-console-btn" class="text-zinc-500 hover:text-zinc-700 dark:text-zinc-600 dark:hover:text-zinc-400 transition-colors">Clear</button>
          </div>
          <div id="console" class="p-2 sm:p-4 font-mono text-xs sm:text-sm text-zinc-600 dark:text-zinc-400 overflow-auto scrollbar-hide flex-1">
            <p class="text-zinc-500">// Output will appear here when you run your code</p>
          </div>
        </div>
      </div>
    </div>
  </div>
</BaseLayout>

<script define:vars={{ examples }}>
  // Store examples in window for access
  window.pixelExamples = examples;
</script>

<script>
  import { EditorView, basicSetup } from 'codemirror';
  import { javascript } from '@codemirror/lang-javascript';
  import { oneDark } from '@codemirror/theme-one-dark';
  import { Compartment } from '@codemirror/state';

  // Suppress ScriptProcessorNode deprecation warning from Emscripten SDL audio
  // This warning is expected until Emscripten SDL2 ports support AudioWorklet
  const originalWarn = console.warn.bind(console);
  console.warn = (...args: any[]) => {
    const msg = args[0]?.toString() || '';
    if (msg.includes('ScriptProcessorNode') && msg.includes('deprecated')) {
      return; // Suppress this specific warning
    }
    originalWarn(...args);
  };

  // Get examples from window
  const examples = (window as any).pixelExamples;

  // Theme compartment for dynamic switching
  const themeCompartment = new Compartment();

  // Check if dark mode is active
  function isDarkMode() {
    return document.documentElement.classList.contains('dark');
  }

  // Light theme that matches the website
  const lightTheme = EditorView.theme({
    '&': {
      height: '100%',
      backgroundColor: '#fafafa',
      color: '#3f3f46'
    },
    '.cm-scroller': { overflow: 'auto' },
    '.cm-content': { caretColor: '#18181b' },
    '.cm-cursor': { borderLeftColor: '#18181b' },
    '.cm-activeLine': { backgroundColor: '#f4f4f5' },
    '.cm-selectionMatch': { backgroundColor: '#e4e4e7' },
    '.cm-gutters': {
      backgroundColor: '#f4f4f5',
      color: '#a1a1aa',
      border: 'none',
      borderRight: '1px solid #e4e4e7'
    },
    '.cm-activeLineGutter': { backgroundColor: '#e4e4e7' },
    '&.cm-focused .cm-selectionBackground, ::selection': { backgroundColor: '#d4d4d8' },
    '.cm-foldPlaceholder': { backgroundColor: '#e4e4e7', color: '#71717a', border: 'none' }
  }, { dark: false });

  // Dark theme extensions
  const darkTheme = [
    oneDark,
    EditorView.theme({
      '&': { height: '100%' },
      '.cm-scroller': { overflow: 'auto' }
    })
  ];

  // Get current theme extensions
  function getThemeExtensions() {
    return isDarkMode() ? darkTheme : lightTheme;
  }

  // Initialize CodeMirror
  const editorContainer = document.getElementById('editor');
  let editor: EditorView;

  // Always start with the first example
  const initialCode = examples[0].code;

  if (editorContainer) {
    editor = new EditorView({
      doc: initialCode,
      extensions: [
        basicSetup,
        javascript(),
        themeCompartment.of(getThemeExtensions())
      ],
      parent: editorContainer
    });

    // Listen for theme changes
    const observer = new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        if (mutation.attributeName === 'class') {
          editor.dispatch({
            effects: themeCompartment.reconfigure(getThemeExtensions())
          });
        }
      }
    });

    observer.observe(document.documentElement, { attributes: true });
  }

  // Example selector - load selected example into editor
  const exampleSelect = document.getElementById('example-select') as HTMLSelectElement;

  exampleSelect?.addEventListener('change', () => {
    const idx = parseInt(exampleSelect.value);
    if (editor && examples[idx]) {
      editor.dispatch({
        changes: {
          from: 0,
          to: editor.state.doc.length,
          insert: examples[idx].code
        }
      });
    }
  });

  // Console output helpers
  const consoleEl = document.getElementById('console');
  function logToConsole(msg: string, className = 'text-zinc-400') {
    if (consoleEl) {
      const p = document.createElement('p');
      p.className = className;
      p.textContent = msg;
      consoleEl.appendChild(p);
      consoleEl.scrollTop = consoleEl.scrollHeight;
    }
  }
  function clearConsole() {
    if (consoleEl) consoleEl.innerHTML = '';
  }

  // Clear console button
  const clearConsoleBtn = document.getElementById('clear-console-btn');
  clearConsoleBtn?.addEventListener('click', clearConsole);

  // UI elements
  const runBtn = document.getElementById('run-btn');
  const stopBtn = document.getElementById('stop-btn');
  const statusBadge = document.getElementById('status-badge');
  const loadingIndicator = document.getElementById('loading-indicator');

  // Show Run button once module is loaded
  function showRunButton() {
    loadingIndicator?.classList.add('hidden');
    runBtn?.classList.remove('hidden');
    runBtn?.removeAttribute('disabled');
  }

  // Update UI for running state
  function setRunningState(running: boolean) {
    if (running) {
      runBtn?.classList.add('hidden');
      stopBtn?.classList.remove('hidden');
      statusBadge?.classList.remove('hidden');
    } else {
      runBtn?.classList.remove('hidden');
      stopBtn?.classList.add('hidden');
      statusBadge?.classList.add('hidden');
    }
  }

  // WASM Module state
  let pixelModule: any = null;
  let isRunning = false;
  let moduleLoaded = false;

  // Get base URL for assets
  function getBaseUrl() {
    const base = import.meta.env.BASE_URL;
    return base.endsWith('/') ? base : base + '/';
  }

  // Load WASM module
  async function loadPixelModule(): Promise<any> {
    if (pixelModule && moduleLoaded) return pixelModule;

    const canvas = document.getElementById('canvas') as HTMLCanvasElement;
    const baseUrl = getBaseUrl();

    return new Promise((resolve, reject) => {
      // Configure Module before script loads
      (window as any).Module = {
        canvas: canvas,
        keyboardListeningElement: canvas,  // Only capture keyboard when canvas is focused
        arguments: [],
        noInitialRun: true,

        print: (text: string) => {
          console.log(text);
          logToConsole(text);
        },

        printErr: (text: string) => {
          console.error(text);
          logToConsole(text, 'text-red-400');
        },

        setStatus: (text: string) => {
          if (text) logToConsole(text, 'text-zinc-500');
        },

        onRuntimeInitialized: async () => {
          pixelModule = (window as any).Module;

          // Preload the bundled font into the virtual filesystem
          try {
            const FS = pixelModule.FS;
            // Create /fonts directory
            try { FS.mkdir('/fonts'); } catch (e) { /* may already exist */ }

            // Fetch and write the font file
            const fontResponse = await fetch(baseUrl + 'fonts/Inter-Regular.ttf');
            if (fontResponse.ok) {
              const fontData = await fontResponse.arrayBuffer();
              FS.writeFile('/fonts/Inter-Regular.ttf', new Uint8Array(fontData));
              console.log('[Playground] Font preloaded successfully');
            } else {
              console.warn('[Playground] Could not load font file');
            }
          } catch (e) {
            console.warn('[Playground] Font preload failed:', e);
          }

          moduleLoaded = true;
          logToConsole('Pixel runtime loaded', 'text-green-400');
          showRunButton();
          resolve(pixelModule);
        },

        onAbort: (what: string) => {
          logToConsole(`Aborted: ${what}`, 'text-red-400');
          isRunning = false;
          setRunningState(false);
        },

        locateFile: (path: string) => {
          return getBaseUrl() + 'wasm/' + path;
        }
      };

      // Load the script
      const script = document.createElement('script');
      script.src = baseUrl + 'wasm/pixel.js';
      script.onerror = () => reject(new Error('Failed to load WASM module'));
      document.body.appendChild(script);
    });
  }

  // Stop the running program
  function stopExecution() {
    if (!isRunning) return;

    logToConsole('Stopping...', 'text-yellow-400');

    // Cancel Emscripten main loop
    const Module = (window as any).Module;
    if (Module && Module._emscripten_cancel_main_loop) {
      Module._emscripten_cancel_main_loop();
    }

    // Remove SDL's keyboard event handlers from window
    // Emscripten registers these globally even with keyboardListeningElement set
    const JSEvents = (window as any).JSEvents;
    if (JSEvents && JSEvents.eventHandlers) {
      const keyboardEvents = ['keydown', 'keyup', 'keypress'];
      for (let i = JSEvents.eventHandlers.length - 1; i >= 0; i--) {
        const h = JSEvents.eventHandlers[i];
        if (keyboardEvents.includes(h.eventTypeString) && h.target === window) {
          h.target.removeEventListener(h.eventTypeString, h.eventListenerFunc, h.useCapture);
          JSEvents.eventHandlers.splice(i, 1);
        }
      }
    }

    // Release focus from canvas
    const canvas = document.getElementById('canvas');
    if (canvas) canvas.blur();

    isRunning = false;
    setRunningState(false);
    logToConsole('Stopped', 'text-yellow-400');
  }

  // Run Pixel code
  async function runPixelCode(code: string) {
    // Stop any existing execution
    if (isRunning) {
      stopExecution();
      await new Promise(r => setTimeout(r, 200));
    }

    clearConsole();
    logToConsole('Running...', 'text-cyan-400');
    isRunning = true;
    setRunningState(true);

    try {
      const module = await loadPixelModule();

      // Write code to virtual filesystem
      const encoder = new TextEncoder();
      const codeBytes = encoder.encode(code);
      const FS = (window as any).FS || module.FS;
      FS.writeFile('/game.pixel', codeBytes);

      // Call main with arguments: pixel run /game.pixel
      const Module = (window as any).Module;
      try {
        if (Module.callMain) {
          Module.callMain(['run', '/game.pixel']);
          // Auto-focus canvas for keyboard input
          const canvas = document.getElementById('canvas');
          if (canvas) canvas.focus();
        } else {
          logToConsole('callMain not available', 'text-yellow-400');
          isRunning = false;
          setRunningState(false);
        }
      } catch (runErr: any) {
        logToConsole(`Runtime error: ${runErr.message}`, 'text-red-400');
        isRunning = false;
        setRunningState(false);
      }

    } catch (err: any) {
      logToConsole(`Error: ${err.message}`, 'text-red-400');
      isRunning = false;
      setRunningState(false);
    }
  }

  // Button handlers
  runBtn?.addEventListener('click', () => {
    const code = editor?.state.doc.toString() || '';
    runPixelCode(code);
  });

  stopBtn?.addEventListener('click', stopExecution);

  // Keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    // Ctrl/Cmd + Enter to run
    if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
      e.preventDefault();
      if (!isRunning) {
        const code = editor?.state.doc.toString() || '';
        runPixelCode(code);
      }
    }
    // Ctrl/Cmd + . to stop
    if ((e.ctrlKey || e.metaKey) && e.key === '.') {
      e.preventDefault();
      if (isRunning) {
        stopExecution();
      }
    }
  });

  // Pre-load the WASM module
  loadPixelModule().catch(err => {
    logToConsole(`Failed to load runtime: ${err.message}`, 'text-red-400');
  });
</script>

<style>
  #editor :global(.cm-editor) {
    height: 100%;
  }
  #editor :global(.cm-scroller) {
    -ms-overflow-style: none;
    scrollbar-width: none;
  }
  #editor :global(.cm-scroller)::-webkit-scrollbar {
    display: none;
  }

  /* Make canvas scale while maintaining aspect ratio */
  #canvas {
    object-fit: contain;
  }
</style>
