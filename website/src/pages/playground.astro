---
import BaseLayout from '../layouts/BaseLayout.astro';

const examples = [
  {
    name: 'Bouncing Ball',
    code: `// DVD-style bouncing ball - changes color on bounce
x = 400
y = 300
dx = 200
dy = 150
color_r = 0
color_g = 255
color_b = 255

function random_color() {
    color_r = random_range(50, 255)
    color_g = random_range(50, 255)
    color_b = random_range(50, 255)
}

function on_start() {
    create_window(800, 600, "Bouncing Ball")
    x = random_range(100, 700)
    y = random_range(100, 500)
    dx = random_range(150, 250)
    dy = random_range(100, 200)
}

function on_update(dt) {
    x = x + dx * dt
    y = y + dy * dt

    if x < 20 or x > 780 {
        dx = -dx
        random_color()
    }
    if y < 20 or y > 580 {
        dy = -dy
        random_color()
    }
}

function on_draw() {
    clear(rgb(20, 20, 40))
    draw_circle(x, y, 20, rgb(color_r, color_g, color_b))
}`
  },
  {
    name: 'Keyboard Movement',
    code: `x = 400
y = 300
speed = 200

function on_start() {
    create_window(800, 600, "Move with Arrow Keys")
}

function on_update(dt) {
    if key_down(KEY_LEFT) {
        x = x - speed * dt
    }
    if key_down(KEY_RIGHT) {
        x = x + speed * dt
    }
    if key_down(KEY_UP) {
        y = y - speed * dt
    }
    if key_down(KEY_DOWN) {
        y = y + speed * dt
    }
}

function on_draw() {
    clear(rgb(20, 20, 40))
    draw_rect(x - 25, y - 25, 50, 50, YELLOW)
    draw_text("Use arrow keys to move", 280, 550, default_font(20), WHITE)
}`
  },
  {
    name: 'Particles',
    code: `particles = []

function on_start() {
    create_window(800, 600, "Click to spawn particles")
}

function on_update(dt) {
    if mouse_pressed(MOUSE_LEFT) {
        i = 0
        while i < 10 {
            p = {}
            p.x = mouse_x()
            p.y = mouse_y()
            p.vx = random_range(-100, 100)
            p.vy = random_range(-200, -50)
            p.life = 1.0
            list_add(particles, p)
            i = i + 1
        }
    }

    i = 0
    while i < list_length(particles) {
        p = particles[i]
        p.x = p.x + p.vx * dt
        p.y = p.y + p.vy * dt
        p.vy = p.vy + 400 * dt
        p.life = p.life - dt
        if p.life <= 0 {
            list_remove(particles, i)
        } else {
            i = i + 1
        }
    }
}

function on_draw() {
    clear(rgb(20, 20, 40))
    i = 0
    while i < list_length(particles) {
        p = particles[i]
        alpha = floor(p.life * 255)
        draw_circle(p.x, p.y, 5, rgba(255, 100, 50, alpha))
        i = i + 1
    }
    draw_text("Click to spawn particles", 280, 550, default_font(20), WHITE)
}`
  }
];
---

<BaseLayout title="Playground">
  <div class="h-[calc(100vh-4rem)] flex flex-col">
    <!-- Toolbar -->
    <div class="border-b border-zinc-200 dark:border-zinc-800 px-4 py-3 flex items-center justify-between bg-zinc-50 dark:bg-zinc-900">
      <div class="flex items-center gap-4">
        <label class="text-sm font-medium">
          Example:
          <select id="example-select" class="ml-2 px-3 py-1.5 bg-white dark:bg-zinc-800 border border-zinc-300 dark:border-zinc-700 rounded-lg text-sm">
            {examples.map((ex, i) => (
              <option value={i}>{ex.name}</option>
            ))}
          </select>
        </label>
        <span id="status-badge" class="hidden px-2 py-1 text-xs font-medium rounded bg-cyan-500/20 text-cyan-400">
          Running
        </span>
      </div>
      <div class="flex items-center gap-2">
        <button
          id="run-btn"
          class="px-4 py-2 bg-cyan-400 text-zinc-900 font-medium rounded-lg hover:bg-cyan-500 transition-colors flex items-center gap-2"
        >
          <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24">
            <path d="M8 5v14l11-7z"/>
          </svg>
          Run
        </button>
        <button
          id="stop-btn"
          class="hidden px-4 py-2 bg-red-500 text-white font-medium rounded-lg hover:bg-red-600 transition-colors flex items-center gap-2"
        >
          <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24">
            <rect x="6" y="6" width="12" height="12"/>
          </svg>
          Stop
        </button>
      </div>
    </div>

    <!-- Main Content -->
    <div class="flex-1 flex min-h-0">
      <!-- Editor Panel -->
      <div class="w-1/2 border-r border-zinc-200 dark:border-zinc-800 flex flex-col">
        <div class="px-4 py-2 text-xs font-medium text-zinc-500 dark:text-zinc-400 bg-zinc-100 dark:bg-zinc-900 border-b border-zinc-200 dark:border-zinc-800 flex items-center justify-between">
          <span>game.pixel</span>
          <span class="text-zinc-400 dark:text-zinc-600 text-[10px]">Ctrl+Enter to run</span>
        </div>
        <div id="editor" class="flex-1 overflow-auto scrollbar-hide"></div>
      </div>

      <!-- Output Panel -->
      <div class="w-1/2 flex flex-col">
        <div class="px-4 py-2 text-xs font-medium text-zinc-500 dark:text-zinc-400 bg-zinc-100 dark:bg-zinc-900 border-b border-zinc-200 dark:border-zinc-800">
          Output
        </div>
        <div id="canvas-container" class="flex-1 bg-zinc-100 dark:bg-zinc-900 flex items-center justify-center overflow-hidden p-4">
          <canvas id="canvas" width="800" height="600" class="max-w-full max-h-full bg-zinc-200 dark:bg-zinc-950 border-2 border-zinc-400 dark:border-zinc-600 rounded"></canvas>
        </div>
        <div class="h-48 border-t border-zinc-200 dark:border-zinc-800 bg-zinc-100 dark:bg-zinc-950 flex flex-col">
          <div class="px-4 py-2 text-xs font-medium text-zinc-500 border-b border-zinc-200 dark:border-zinc-800 flex items-center justify-between shrink-0">
            <span>Console</span>
            <button id="clear-console-btn" class="text-zinc-500 hover:text-zinc-700 dark:text-zinc-600 dark:hover:text-zinc-400 transition-colors">Clear</button>
          </div>
          <div id="console" class="p-4 font-mono text-sm text-zinc-600 dark:text-zinc-400 overflow-auto scrollbar-hide flex-1">
            <p class="text-zinc-500">// Output will appear here when you run your code</p>
          </div>
        </div>
      </div>
    </div>
  </div>
</BaseLayout>

<script define:vars={{ examples }}>
  // Store examples in window for access
  window.pixelExamples = examples;
</script>

<script>
  import { EditorView, basicSetup } from 'codemirror';
  import { javascript } from '@codemirror/lang-javascript';
  import { oneDark } from '@codemirror/theme-one-dark';
  import { Compartment } from '@codemirror/state';

  // Get examples from window
  const examples = (window as any).pixelExamples;

  // Theme compartment for dynamic switching
  const themeCompartment = new Compartment();

  // Check if dark mode is active
  function isDarkMode() {
    return document.documentElement.classList.contains('dark');
  }

  // Light theme that matches the website
  const lightTheme = EditorView.theme({
    '&': {
      height: '100%',
      backgroundColor: '#fafafa',
      color: '#3f3f46'
    },
    '.cm-scroller': { overflow: 'auto' },
    '.cm-content': { caretColor: '#18181b' },
    '.cm-cursor': { borderLeftColor: '#18181b' },
    '.cm-activeLine': { backgroundColor: '#f4f4f5' },
    '.cm-selectionMatch': { backgroundColor: '#e4e4e7' },
    '.cm-gutters': {
      backgroundColor: '#f4f4f5',
      color: '#a1a1aa',
      border: 'none',
      borderRight: '1px solid #e4e4e7'
    },
    '.cm-activeLineGutter': { backgroundColor: '#e4e4e7' },
    '&.cm-focused .cm-selectionBackground, ::selection': { backgroundColor: '#d4d4d8' },
    '.cm-foldPlaceholder': { backgroundColor: '#e4e4e7', color: '#71717a', border: 'none' }
  }, { dark: false });

  // Dark theme extensions
  const darkTheme = [
    oneDark,
    EditorView.theme({
      '&': { height: '100%' },
      '.cm-scroller': { overflow: 'auto' }
    })
  ];

  // Get current theme extensions
  function getThemeExtensions() {
    return isDarkMode() ? darkTheme : lightTheme;
  }

  // Initialize CodeMirror
  const editorContainer = document.getElementById('editor');
  let editor: EditorView;

  if (editorContainer) {
    editor = new EditorView({
      doc: examples[0].code,
      extensions: [
        basicSetup,
        javascript(),
        themeCompartment.of(getThemeExtensions())
      ],
      parent: editorContainer
    });

    // Listen for theme changes
    const observer = new MutationObserver((mutations) => {
      for (const mutation of mutations) {
        if (mutation.attributeName === 'class') {
          editor.dispatch({
            effects: themeCompartment.reconfigure(getThemeExtensions())
          });
        }
      }
    });

    observer.observe(document.documentElement, { attributes: true });
  }

  // Example selector
  const exampleSelect = document.getElementById('example-select') as HTMLSelectElement;
  exampleSelect?.addEventListener('change', () => {
    const idx = parseInt(exampleSelect.value);
    if (editor && examples[idx]) {
      editor.dispatch({
        changes: {
          from: 0,
          to: editor.state.doc.length,
          insert: examples[idx].code
        }
      });
    }
  });

  // Console output helpers
  const consoleEl = document.getElementById('console');
  function logToConsole(msg: string, className = 'text-zinc-400') {
    if (consoleEl) {
      const p = document.createElement('p');
      p.className = className;
      p.textContent = msg;
      consoleEl.appendChild(p);
      consoleEl.scrollTop = consoleEl.scrollHeight;
    }
  }
  function clearConsole() {
    if (consoleEl) consoleEl.innerHTML = '';
  }

  // Clear console button
  const clearConsoleBtn = document.getElementById('clear-console-btn');
  clearConsoleBtn?.addEventListener('click', clearConsole);

  // UI elements
  const runBtn = document.getElementById('run-btn');
  const stopBtn = document.getElementById('stop-btn');
  const statusBadge = document.getElementById('status-badge');

  // Update UI for running state
  function setRunningState(running: boolean) {
    if (running) {
      runBtn?.classList.add('hidden');
      stopBtn?.classList.remove('hidden');
      statusBadge?.classList.remove('hidden');
    } else {
      runBtn?.classList.remove('hidden');
      stopBtn?.classList.add('hidden');
      statusBadge?.classList.add('hidden');
    }
  }

  // WASM Module state
  let pixelModule: any = null;
  let isRunning = false;
  let moduleLoaded = false;

  // Get base URL for assets
  function getBaseUrl() {
    const base = import.meta.env.BASE_URL;
    return base.endsWith('/') ? base : base + '/';
  }

  // Load WASM module
  async function loadPixelModule(): Promise<any> {
    if (pixelModule && moduleLoaded) return pixelModule;

    const canvas = document.getElementById('canvas') as HTMLCanvasElement;
    const baseUrl = getBaseUrl();

    return new Promise((resolve, reject) => {
      // Configure Module before script loads
      (window as any).Module = {
        canvas: canvas,
        arguments: [],
        noInitialRun: true,

        print: (text: string) => {
          console.log(text);
          logToConsole(text);
        },

        printErr: (text: string) => {
          console.error(text);
          logToConsole(text, 'text-red-400');
        },

        setStatus: (text: string) => {
          if (text) logToConsole(text, 'text-zinc-500');
        },

        onRuntimeInitialized: async () => {
          pixelModule = (window as any).Module;

          // Preload the bundled font into the virtual filesystem
          try {
            const FS = pixelModule.FS;
            // Create /fonts directory
            try { FS.mkdir('/fonts'); } catch (e) { /* may already exist */ }

            // Fetch and write the font file
            const fontResponse = await fetch(baseUrl + 'fonts/Inter-Regular.ttf');
            if (fontResponse.ok) {
              const fontData = await fontResponse.arrayBuffer();
              FS.writeFile('/fonts/Inter-Regular.ttf', new Uint8Array(fontData));
              console.log('[Playground] Font preloaded successfully');
            } else {
              console.warn('[Playground] Could not load font file');
            }
          } catch (e) {
            console.warn('[Playground] Font preload failed:', e);
          }

          moduleLoaded = true;
          logToConsole('Pixel runtime loaded', 'text-green-400');
          resolve(pixelModule);
        },

        onAbort: (what: string) => {
          logToConsole(`Aborted: ${what}`, 'text-red-400');
          isRunning = false;
          setRunningState(false);
        },

        locateFile: (path: string) => {
          return getBaseUrl() + 'wasm/' + path;
        }
      };

      // Load the script
      const script = document.createElement('script');
      script.src = baseUrl + 'wasm/pixel.js';
      script.onerror = () => reject(new Error('Failed to load WASM module'));
      document.body.appendChild(script);
    });
  }

  // Stop the running program
  function stopExecution() {
    if (!isRunning) return;

    logToConsole('Stopping...', 'text-yellow-400');

    // Cancel Emscripten main loop
    const Module = (window as any).Module;
    if (Module && Module._emscripten_cancel_main_loop) {
      Module._emscripten_cancel_main_loop();
    }

    isRunning = false;
    setRunningState(false);
    logToConsole('Stopped', 'text-yellow-400');
  }

  // Run Pixel code
  async function runPixelCode(code: string) {
    // Stop any existing execution
    if (isRunning) {
      stopExecution();
      await new Promise(r => setTimeout(r, 200));
    }

    clearConsole();
    logToConsole('Running...', 'text-cyan-400');
    isRunning = true;
    setRunningState(true);

    try {
      const module = await loadPixelModule();

      // Write code to virtual filesystem
      const encoder = new TextEncoder();
      const codeBytes = encoder.encode(code);
      const FS = (window as any).FS || module.FS;
      FS.writeFile('/game.pixel', codeBytes);

      // Call main with arguments: pixel run /game.pixel
      const Module = (window as any).Module;
      try {
        if (Module.callMain) {
          Module.callMain(['run', '/game.pixel']);
        } else {
          logToConsole('callMain not available', 'text-yellow-400');
          isRunning = false;
          setRunningState(false);
        }
      } catch (runErr: any) {
        logToConsole(`Runtime error: ${runErr.message}`, 'text-red-400');
        isRunning = false;
        setRunningState(false);
      }

    } catch (err: any) {
      logToConsole(`Error: ${err.message}`, 'text-red-400');
      isRunning = false;
      setRunningState(false);
    }
  }

  // Button handlers
  runBtn?.addEventListener('click', () => {
    const code = editor?.state.doc.toString() || '';
    runPixelCode(code);
  });

  stopBtn?.addEventListener('click', stopExecution);

  // Keyboard shortcuts
  document.addEventListener('keydown', (e) => {
    // Ctrl/Cmd + Enter to run
    if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
      e.preventDefault();
      if (!isRunning) {
        const code = editor?.state.doc.toString() || '';
        runPixelCode(code);
      }
    }
    // Ctrl/Cmd + . to stop
    if ((e.ctrlKey || e.metaKey) && e.key === '.') {
      e.preventDefault();
      if (isRunning) {
        stopExecution();
      }
    }
  });

  // Pre-load the WASM module
  loadPixelModule().catch(err => {
    logToConsole(`Failed to load runtime: ${err.message}`, 'text-red-400');
  });
</script>

<style>
  #editor :global(.cm-editor) {
    height: 100%;
  }
  #editor :global(.cm-scroller) {
    -ms-overflow-style: none;
    scrollbar-width: none;
  }
  #editor :global(.cm-scroller)::-webkit-scrollbar {
    display: none;
  }

  /* Make canvas scale while maintaining aspect ratio */
  #canvas {
    object-fit: contain;
  }
</style>
